---
id: '10'
lezione: "20231031"
title: "Memory error exploits - Smashing the stack"
author: "Sam. Kaluwaduge"
keywords: 
---

<style>
    strong{
        background-color:#faf43e;
        color: black;
        padding:0.1rem 0.2rem;
        border-radius:5px;
    }
</style>

# Memory error exploits - Smashing the stack

è la tecnica usata morris per internet worm

articolo da leggere : di aleph one published on phrack

è possibile farlo attraverso overflow

da linux a win cambiano indirizzi di riferimento.
ilprogramma viene caricato

kernel space, stack 

x var globale in datasegment
var y statico in bss segment
variabili del  main in stack
è il compilatore a decidere dove mettere i variabili 

malloc (2*sizeof int) alloca 8byte

perchè si usa lo stack, perchè è molto comodo,
lo usa compilatore, lifo,

per questioni di optimizzazioni, 
tutti usano quel area. si alloc quando serve e viene cancellato quando nn servono piu, ottimizzazione 

in stack si puo allocare in multpli di 64bit

molti cpu hanno hanno istruzioni, regs dedicati per operazioni sullo stack. (rsp)

ogni proc ha il suo stack. e os ha uno suo è il giga in alto.
per sapere quale. si usa reg SS stacksegment
rsp ultimo 

    push reg/immg  -> 
    sub rsp,8, 
    mov [rsp],reg/imm

non si puo fare push "data" (memoria)
push carica dentro rsp e diminuisce di 8

istruzione pop
pop rax cari dentro rax il contenuto e sposto rsp di 8 su.

## stack and function calls

stack frame

layout di stack 

main con var x
foo con var 10
tutte le variabili locali di foo (ii,,iii,)
bar con j
e suoi var locoali

ci sono due reg che si muovono rbp e rsp


gno volta che una funzione viene chiamata, viene creata lo stack frame la memoria allocata all interno dello stack viene mantenuta ...
lo stack frame viene delimitato da rbp e rsp

allocato un buffer di 1024 byte chiamato name

ptr func
& name
main (name 1024)

la gestione degli indirizzi di ritorno, quando siamo allinterno della main e facciamo call alla funzione, dobbiamo tornare alla istruione successiva della call.

la call mette sullo stack rip e fa un jmp incondizionata alla funzione.
la ret fa un pop dalllo stack rip salvato prima.

il problema stack pointer con rip

fino 6 parametri si usa la convenzione linux 64bit rdi,rsi,rdx,r8,r9 , se li supera li carica nello stack.

è il compilatore che si occupa di caricare nei registri i parametri della funzione.

rbp è il base ppointer 

prologue
prima di una chiamata a funzione il compilatore inserisce all'interno della funzione un prologo.
viene salvato rbp sullo stack,
metto dentro rbp,rsp
riverso unpo di stack per variabili locali.

    push rbp
    mov rbp,rsp
    sub rsp, tot

epilogo 

    mov rsp, rbp
    pop rbp
    ret


rbp punta all'inizio di stack
rsp si muove liberamente

call mette sullo stack i parametri
e poi carica il return address

~~~c
#include <stdio.h>

int main(){
	char buf[80];
	int cookie;
	
	printf("buf: %08x cookie: %08x\n",&buf,&cookie);
	gets(buf);

	if(cookie == 0x41424344)
		printf("You Win!\n");
}
~~~
~~~
    1189:       f3 0f 1e fa             endbr64 
    118d:       55                      push   %rbp
    118e:       48 89 e5                mov    %rsp,%rbp
    1191:       48 83 ec 60             sub    $0x60,%rsp
    1195:       48 8d 55 fc             lea    -0x4(%rbp),%rdx
    1199:       48 8d 45 a0             lea    -0x60(%rbp),%rax
    119d:       48 89 c6                mov    %rax,%rsi
    11a0:       48 8d 3d 5d 0e 00 00    lea    0xe5d(%rip),%rdi        # 2004 <_IO_stdin_used+0x4>
    11a7:       b8 00 00 00 00          mov    $0x0,%eax
    11ac:       e8 cf fe ff ff          callq  1080 <printf@plt>
    11b1:       48 8d 45 a0             lea    -0x60(%rbp),%rax
    11b5:       48 89 c7                mov    %rax,%rdi
    11b8:       b8 00 00 00 00          mov    $0x0,%eax
    11bd:       e8 ce fe ff ff          callq  1090 <gets@plt>
    11c2:       8b 45 fc                mov    -0x4(%rbp),%eax
    11c5:       3d 44 43 42 41          cmp    $0x41424344,%eax
    11ca:       75 0c                   jne    11d8 <main+0x4f>
    11cc:       48 8d 3d 49 0e 00 00    lea    0xe49(%rip),%rdi        # 201c <_IO_stdin_used+0x1c>
    11d3:       e8 98 fe ff ff          callq  1070 <puts@plt>
    11d8:       b8 00 00 00 00          mov    $0x0,%eax
    11dd:       c9                      leaveq 
    11de:       c3                      retq   
    11df:       90                      nop

~~~

per evitare stack smashing 
compilatore inverte l'ordine
cosi andiamo riscrivere dati del sistema cosi il sistema se ne accorge

flag da mettere per disabilitare stack smashing è -fno-stack-protector
ex da fare a casa
~~~
int main(){
    int cookie
}
~~~

## Memory corruption exploits
* stack overflow
* heap overflow
* format string
* integer overflow
* return to libc

* predisporrre il codice per attaco il shellode
  
esistono due strategie 
salta al codice precedentemente 

ret2libc 
il shellcode è già prensente nelle librerie è caricato in user space.

hijacking del flusso di controllo

stack de lmain
ra, x
stack del funzione function
ra, old rbp,ret,x

funzione parte e fa x+13
assrgna all indirizzo di ret + 8
indirizzo ret dovrebbe puntare a RA
adesso al RA return addres sommo un numero per arrivare a printf del main
cosi faccio salatare istruzioni

dovrebbe essere 16 su 64bit invece di 8


~~~c
#include <stdio.h>
int x=0;
int function(){
    int * ret;
    x=x+13;
    ret = (int *) &ret + 16 // or 8
    (*ret) = (*ret) + 8; // numero da trovare
}
int main(){
    x=function();
    x=10;
    printf("Value of x = %d\n",x);
}
~~~

questo eserciz mostra che possiamo modificare il flusso di un programma.

primi due per buffer overflow
proteioni di kernel contro buffer overflow
echo 0 > /proc/sys/kernel/randomize_va_space
sudo sysctl -w kernel.randomize_va_space=0
ulimit -c unlimited per aumentare il corre dumb
per vedere core dump in gdb
gdb -q executable core


0x90 per operazione NOP
ricordare di usare little endian

