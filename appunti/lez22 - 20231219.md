---
id: '22'
lezione: "20231219"
title: ""
author: "Sam. K."
keywords: [""]
---

<style>
    strong{
        background-color:#faf43e;
        color: black;
        padding:0.1rem 0.2rem;
        border-radius:5px;
    }
</style>

# Applicazione della crittografia alla cybersecurity

Network security: IPSEC

il protocollo che viene usto a livello di rete ipsec 
è un sottomudlo di ipv6 messo in ipv4

img ip packet header

obiettivo di pisec è cifrare e autenticare il traffico a livello ip,
 è stato sviluppat oper ipv6 ma adattato per ipv4

rfc 4301-430...

rfc 4835
cifrari usati
aes cbc 128bit
tripple des cbc 168bit

message authentication / integrity
hash hmac, usa
hmac sha1-96

ipsec servizi
autenticazione del mittente previe ip spoofing
confidenzialita
integrità
sul singolo pacchetto
partial seq integrity previene packet replay (no replay attack)

possibile nascondere infdirizzo ip del mittente limited trffic flow confidentiality

importante questi servizi sono trasparente alle aplicazioni (a livelli sopra transport layer)
tcp/udp layer

ipsec viene 

AH autentication header: autenticazione servii di integrità
fa il controllo di in realtà integrità sul intero pacchetto


esp encapsulated sec payload, integrita sul payload ma nn su header

esp in most cases is the only one needed
ah non è piu obbligatorio

pacchetto normale ipsec

ip header |ipsec header| ip header| tcp header| data

puo operazione in deu modelita in tunnel mod e transport mod

parto da un ip packet -> trasformo in ipsec

in tunnel mod il packet viene in un pacchetto ip
per reggira transsazione da ipv4 a ipsec, dato che tutte i router non sono configurati per ipsec

tunnel mod mette ip header ipsec al packet ip normale, alla destinazione viene tolto il wrapping

tnnel mod viene usato cn vpn

AH 
si prende ip packet, ah header si crea sha con autentication key quello di nuovo sha con aute key

integrity check value viene init a zero

esp
garantisce confidenziali del payload e integrita

ipsec protocollo 50 esp, 51 per AH

||transport mod|tunnel mod|
|-|-|-|
|ah |
|esp|
|esp with autentication|

come vien implementato?

bisogna lavorare a livello di sitema cambiando 

security policy database

le sp specificano che tipo di traffico se sul quel traffico bisognare un trasformaione crittografica, trasformaione vogliamo effettuaare sul packet se voglia usare tunnel mod oppure trasnposrt mod

source, destitination, ports, protcol (udp ,tcp ,etc)
flow direction, action (none ,discard,ipsec)
sp mode mode(tuneel, transport)
sa name security association name
sp name 

security association db che dice come implementare

perché è diviso? perche in caso di vulnerabilità basta cambiare il codice invece di cambiare le policy

per ogni coppia host che cosa bisogna fare

all'inizio la configurazione era manuale

è stato automatizzato cn il protocollo
sa amangement thrgough ikev2
ike+isakmp+others
on-demand sa creation
session

a livello ip packet da spedire con ip s,d e ports, con quest campi si accede alle sp del database, cerco di capire cosa ce scritto se ipsec, vado controllare 
AH,

SA, butto in rete

stessa cosa per traffico in ingresso
viene usato spi del esp per accedere al SA DB

benefici si ipsec
fornisce un buon livello sicurezza a tutti livelli 
trasparente ai programmatore
facilmente estendibile a nuovi protocolli crittografici

svantaggi 
rellentamento del traffico, cifratura cosa (simmetrica é veloce ) (ike usa diffie hellman)
messaggi broadcast nn si puo fare

blocks access to non-ipsec hosts

hosts must have security association
not great for short lived connections

not practical for broadcast

# transport level security - TLS / SSL
ipsec nasce dopo security tcp

inizialmetne pensato da netscape rfc 2246 obiettivo è quello stabili un canale sicuro tra due host a livello trasporto

tls 1.3 rfc 8446 aug 2018

server authentication 
client authen
data confidentiality
data integrity

come funziona? ssl / tls standard

x.509
 usa per auteticazione rsa, dh, dss, fortezza

encryption
rc4 (40-128)
des (40-128)
3des
aes

hashing 
md5
sha1


sopra tcp vien post oil layer tls

handshake protocol 
 serve perché client e server stabiliscono le cchiavi
record protocol

si decide gli algo di critto
scambialo le chiavi
data exchange

come funziona handshake?
viene mandato un numero casuale a server
server risponde 
chiave pubblica del srver a client
server hello done
client calcola la premaster secret


cyphersuite sono due byte rappresentano le modalità con cui client e server vogliono comunicare


una volta scelto algo calcola master secret con sha per ottenere la chiave di 48byte

a cui derivano 4 chiavi + 2

client cifra una chiave diversa da server 

ci puo essere un problema di mitm

per risolvere mitm, si usano certificati
server manda oltre alla chiave pubblica anche il certificato firmato da CA

autenticazione attraverso il certificato è obbligatoria

anche il server puo chiedere al client il certificato

si fa solo autenticazionedel server


record protocol
una volta definiti le chiavi
il reco proto prende il packet tcp fa un compressione calcola il mac, fa la cifratura, aggiunge header e invia

tls flaws and breaches
vulnerabilit a livello tls
beast 2011
attacco heartbleedrubava  private keys

pricnipale 
non è rtasparente a livello applicazione

per cui tutte le app che vogliono cifrare a a livello trasport devono essere modificiati.


end to end

gmail tls tcp ip

mail in chiaro passa a tls che lo cifra passa a tcp a ip

ip [tutto cifrato]

da ip passa tcp che a sua volta passa a tls che lo decifra

per non essere letto a bisogna farlo end to end

viene letto tra tls e gmail

cn end to end viene decifrato a dal applicazione

telegram usa mtproto
whatsapp e signal usa protcollo signal

problema diffie hellman

servirebbe un diffie hellman non interattive

mtproto prevede
due mod cloud chats e secret chats

in caso clloud sono memorizati in chiaro sul server invece secrete sn memorizaati cifrati

cloud chats mtproto 2.0

nelle screte chat dH viene fatto tra A e B 

problema è che il server potrebbe fare mitm

assume che il serve sia fidato.

BIASED

signal protocol

è bsato su diffie hellman
usa la curva elilitica curve25519

fase di registrazione 
in cui vengon generate e memorizzati in un database

ad ogni messaggio di whatapp viene generato una chiave differente

key ratchet

signal vs mtproto
ogni msg viene cifrato cun una chiave differente
mtproto cifra tutti msg cn una chiave

# lab

web of trust

openpgp

docker run -it ubuntu /bin/bash

generare una chiave
gpg --list-keys
gpg --full-generate-key
tipo di chiave
grandezza della chiave
nome, email, etc
password

keyserver.ubuntu.com

si prende l'hash

gpg --keyerver keyserver.ubuntu.com --recv-keys hashdellachiave

uid unknown la fiducia, 

gpg --edit-key "nome / hash della chiave"

entro in interfaccia gpg

trust qunto mi fido della firma

sign per firmare la chiave scaricato

save per uscire

trust permette di camiare la trust di quella chiave, 1,2,3,...,5
5 riservato per la mia chiave

a questo punto le chiavi firmati dalal chiave scaricata permette di fare trust sulle chiave trustate 

firmare un file (asimmetrico)
gpg --output file.txt.enc --encrypt --recipient "Nome" file.txt

gpg --output outfile.txt --decrypt file.txt.enc 

gpg -o file.txt.aes --symmetric --cipher-algo AES256 file.txt
gpg -o file.txt.aes -d file.txt # decryption

per firmare
gpg --output file.txt.sig --sign file.txt 

appende il file con la firma

gpg --output file.txt.sig --detach-sign file.txt # per staccarlo dal file

per verifcare una firma

gpg --verify file.txt.sig file.txt
dice info sulla firma

per esportare la chiave
gpg --export 

john the ripper

campo gecos contien info personali del utente

etc shadow 

tra $...$ ci mette il salt

single mode usa il campo gecos per decifrare il password nome utente, indirizzo, ecc.


