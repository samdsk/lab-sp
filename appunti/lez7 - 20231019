---
id: '7'
lezione: "20231019"
title: ""
author: "Sam. Kaluwaduge"
keywords: 
---

# Playing with assembly

le direttive sono precedute da un punto "."

    label opcode operands 

    LOOP: add rax, 3
        jmp LOOP

    // assegna symbolic name to the

dti posson oessere messi in var o regs, reg ha il tempo di accesso piu veloce di tutt.
procesore puo manipolare solo dati dentro in registro

ax si accede 

registro a 64 bit
rax, ultimi 32 bit di questo reg è eax, ultimi 16 bit è ax, ah sono 8 di left al 8 bit di right
rax | eax | 

questo per dare back compati per processori precedenti

in assebmler ci sono solo dati di tpo numeri o lettere

numeri sn rappresentati in binario

per charatteri si usa unicode utf-8

1  = 0x31 in hex
100 = 0x64 in hex

in formato char ogni char è rappresentato da 2 byte

resb rese byte
resw un word
resq arrya of ten reals
databyte db 0x55 
db 'hello',

   usare # per commenti

le modalita con cui si accede ai dati si chiama addressing mode
tre modalit princ  per regs
per imm access odiretto acc indiretto

diretto usa registri in modalita 


reg addressin -> sposta dati da un reg al altro
mov rdx, rcx
da rdx -> rcx

indiriz immediato
mov dword ptr rax,12
mov dword ptr rax,0x80
// sposta per 32byte all interno di dword il valore 0x80 dentro rax
ptr can be avoided in some assembly languages

imm mod is used to load direct values into regs, for ex. if you want to load the number 128 into rax, must specify the size and write following: would simply do the following

è richiesto al programmatore di specificare quando è ambiguo 

indirizzamento indiretto tramite puntatori (stano dentro i registri)
mov rcx, [rax]
sposto in rcx il contenuto della locazione di memoria di rax (usa il puntatore dentro rax per andare cercare il contenuto nel indirizzo di memoria contenuto in rax)
eax reg stores 64bit adrres
read the data stores at the address
load value into the rcx reg

[number]
[reg]
[reg+reg*scale] scale is 1,2,4, 8 only
[reg+number]

xor rax // serve per azzerare il contenuto a della regs
xor abx
lea rcx,a
sumloop:
mov [rcx + rax*4], rdx
add rbx,rdx
inc rax
cmpl rax,19
jle sumloop

eax=??
ebx=sum
ecx=a

int a [20]
...
inti,nums=0
for(i=0;i<20;i++>)
sum+=a[i]

gcc syntax
lea rcx, buffer # the adddre of buffer is loaded in rcx load effective address
move, rax, [rcx] # the value contained in buffer  si loaded in rax

se conosco a priori l'indirzzo di memoria posso usare questo
mov rcx, 0x20000 # the value 2000 s loaded in rcx
mov rax, [rcx]

differenza
direct add
* fast but less flexible
* memori addres is directly specified in the instruction

indirect addre
more flexib
uses regis or value as pointers

mov eax,0xc001ca75 sets rax to c0 01 ca 75
mov rcx, 0x10000
mov [rcx], eax stored data as 75 ca 01 c0
mov bh, [rcx] reads 0x75 bh  sono bit piu sigificativi della reg bx

bytes are only shuffled for multibyte shotes ans loads of register to memory
individual bytes never have thier bits shuffled
yes, writed to the stack behave just like any othere write to memory

8008 usava little endian, perchè veniva più facile la progettazione dell'ALU nel 1972


istruzioni aritmetiche

add dest,source
sub dest, source
inc dest
dec dest
neg dest
cmp source1,source2 # s2-s1

mul usigned or imul signed puo avere due operandi o uno, se nn è specificato è dentro rax, risultato viene messo in rdx:eax (si puo perdere il contenuto del rdx e eax)
div unsigned or idiv signed


and()
or ...

shift ..

control flow

cmp rax,0
je end_loop
je is flow control instruction jump which says to jump to the label end_loop
cmp compare two values, and stores the res of the comparison in the status reg RFLAGS

je, jg, jge,jl,jle, ...


assembl yusa syscall per fare ops complicate

linux syscall are called
store the syscall number in rax
set up the args to the sys call in rdi,rsirdx,r10,r8,r9
exec the syscall instruc

per leggere da tastiera syscall 0


sysred rdi 

gcc -nostdlib -static -o helloworld 

www.x86-64.org/documentation/abi.pdf



es di syscall

n = read(o,buf,100);

mov rdi,0
mov rsi,rsp
mov rdx, 100
mov rax, 0
syscall


write(1,buf,n);

mov rdi,1
mov rsi,rsp
mov rdx, rax
mov rax,1
sycall




.intel_syntax noprefix
.global _start

.section .text
_start:
    mov rdi,0x13
    
    
    objcopy  -d ex1
    objcopy --dump-section .text-ex1.text ex1
    cat ex1



























